---
layout: post
title:  Hermit Programmers are Dead
subtitle: Don't call yourself a programmer anymore
tags: career
description: |
  The era of the lone, isolated programmer is coming to an end. With the rise of cloud computing, AI, and automation, programmers must evolve into versatile software engineers, embracing collaboration, communication, and a broader skill set. This post explores why programmers who don't diversify their skills or adapt to new technologies will be left behind in a rapidly changing industry.
keywords: programmers, dead, artificial intelligence, machine learning
image: ../img/posts/2021/ladybug_cover.jpg
share-img: ../img/posts/2021/ladybug_cover.jpg
toc: true
author: cesarsotovalero
show-avatar: false
date: 2021/7/31
published: true
---

It's 2021, and the job market has crashed due to a ghastly [global pandemic](https://www.nytimes.com/interactive/2020/06/10/world/coronavirus-history).
At the same time, one particular job has taken over an idealized professional place: the "computer programmer."
They are perceived to be experts who know how to build, fix, and deploy software artifacts.
Most of them prefer to live in airtight environments, where the pieces of the software puzzle to be solved can be more easily isolated.
That being said, at no other time in history has a technology-based profession being so courted, demanded, highly paid.
The reason: software is everywhere in today's world, and it doesn't write itself (so far).
However, with the advent of cloud computing and AI, the scenery may change soon for this profession.
So I think it's time for programmers to mutate into "sociable software engineers," recap and re-adapt, and take advantage of the only thing that machines cannot overtake: our human nature.
Otherwise, I believe a ton of misfit programmers will perish... for sure.

**NOTE:** This article received [125+ comments](https://news.ycombinator.com/item?id=28744671) on Hacker News.

<figure class="jb_picture">
  {% responsive_image path: img/posts/2021/ladybug.jpg alt: "A solitary ladybug posing at Kampementsbacken, Stockholm" %}
  <figcaption class="stroke">
    &#169; A solitary ladybug hacking a dandelion at Kampementsbacken, Stockholm
    </figcaption>
</figure>

# The Good Old Days

In the past, it was rare to find people who understood how these big old computers of the last century were working.
Even more challenging was finding who could program those computers to solve real-world problems.
It was a time when traditional education could not meet the high demand for graduate programmers.
In the 90s, being entitled as a Linux system administrator or database engineer guaranteed professional success and a hefty paycheck at the end of the month.
The most talented programmers were heavily disputed between medium and large companies.

In the beginning, there was an abyss between programmers and their managers.
Computers were significantly more expensive than programmers.
This situation encouraged [the hacker mentality](https://www.yegor256.com/2014/10/26/hacker-vs-programmer-mentality).
People that lived by and for their own coding creations, pleasing managers from time to time,  without caring if others can understand what their code does (or how).
This was possible in part because the number of available technologies (software + hardware devices) was so limited that, for instance, a C programmer could literally code for any available platform; and we all know how cryptic can easily become a piece of driver code written in C.

Today, the situation has changed radically.
It is common for a single person to own at least three computing devices (PC + phone + tablet).
Meanwhile, traditional education is losing more and more territory in the technological arenas.
It seems that the pace of technology is faster than the update of university curriculums are :confused:.
Although the algorithmic principles stay mostly the same, it is in the latest technology space where recent graduates have to prove themselves to succeed in the job market.

The number of new technologies appearing every day, such as programming languages or gadgets, overwhelms human comprehension.
Simply put, the world has never been simple, but today (thanks to technology), it is more complex than ever (especially for programmers).

# The Advent of Machines

Today, it is hard to imagine how startups and small IT businesses installed and maintained their servers at the beginning of this century.
They even paid for the running OS and all the databases were proprietary software.
Fortunately, virtualization services and Infrastructure as a Service (IaaS) providers changed the game.
The management of system infrastructure through third-party services (e.g., AWS, Azure, or Google Cloud) came to simplify all the phases of the software development lifecycle.
Deploying large software applications is now cheaper and better than ever before.

Developers now have a horde of machines at their disposal, living on the cloud.
On-demand computing permits self-scaling software resources almost infinitely.
As buying bananas in the supermarket, if you want more SSD storage or CPU processors, you just need to add them to the basket.
Infrastructure as Code (IaC) facilitates deploying and updating, in minutes, very complex software architectures using a single human-readable YAML file.

Managers don't worry too much about what capacity is needed, spending most of the efforts on the business-specific logic while trying to economize the budget they have.
On the other hand, programmers don't care too much about handling low-level infrastructure or writing the fastest piece of code.
The code that "works" is good enough, the infrastructure that brings economic revenues is the good one.

The number of programmers is constantly on the rise, but many programmers no longer need to be experts, middle-skilled developers now do what needed an expert before, and experts now do what needed a team ten years ago.
Having all the services as standardized APIs and a few packages that can access them all, suddenly, the most complex programming task becomes a plumbing activity where no programmers are needed.

The biggest impact is probably driven by the AI technologies powered by this massive cloud and data storage infrastructures.
For example, Microsoft recently announced [GitHub Copilot](https://copilot.github.com/), an AI-based system to assist developers in their daily routines.
The system can write entire programs based on just the developer's intention, and it is feeded by the billion lines of code hosted on GitHub.
Researchers are just starting to explore the potential of [machine learning for big code and naturalness](https://ml4code.github.io/papers).
Perhaps someday we'll have [cognitive AI](https://towardsdatascience.com/the-rise-of-cognitive-ai-a29d2b724ccc) writing entire complex software from scratch and [passing the Turing Test](https://lacker.io/ai/2020/07/06/giving-gpt-3-a-turing-test).
Today the discussion is not whether or not this will happen, but when.

# The Future

The future of programming is certainly uncertain.
As described by Bret Victor in [his brilliant talk](http://worrydream.com/dbx), programming is in constant evolution.
However, the future of programmers seems more predictable to me.

In the short term, the demand for programmers will shift in nature.
As expected, there will be better frameworks, cloud services, languages, and libraries that will automate a huge chunk of the manual tasks that involve coding.
Programmers will need to know about the existence of more tools than ever, but in much less depth due to the use of Software as a Service (SaaS) solutions.
Advances in program synthesis will undoubtedly make the life of programmers easier.
They could be used for figuring out alternative ways of solving a problem or for possible optimizations.
They'll also make the life of users of computers easier by allowing them to perform everyday repetitive tasks quickly.
And all of this with less code involved.
For instance, the [no-code](https://en.wikipedia.org/wiki/No-code_development_platform) movement will continue its expansion, as well as GUI-based programming tools.
Just as tools like WordPress, Bootstrap, or Heroku simplified the development process some time ago, there will be similar tools for more specific tasks.
Therefore, the future programmer will probably write less code and expend more time thinking about the different existing alternatives for solving a particular problem.

Thus, writing a bunch of code [is not going to be a cool thing to do anymore](https://www.linkedin.com/pulse/programming-dead-we-have-killed-aaron-lai-cfa): thinking about how to assembly existing software pieces to solve problems with computers will.
Programmers should understand these solutions, their limitations, their security implications, their privacy implications, etc.
And, of course, programmers should be able to fix things when they go wrong and invent new things to solve classes of problems that weren't solved before or weren't solved in satisfactory ways.
But the principal focus of attention will be put on the business model and the people around the business.
Communicating with colleagues, both written and spoken, will be essential for programmers.
The ability to plan an idea, convince managers, execute and test it several times, collect feedback from clients, refactor the code, document, talk about it, iterate, and evolve.
Can hermit programmers from the past century do all of that? Very unlikely.

> "I have personally come across several programmers who only program in my career. And even though I was a recent junior, I didn't want to work with people like that." -- <cite>Commented by a LinkedIn user</cite>.

In the foreseeable future, the reality is that there is more demand for programming skills than ever before.
Programming as a profession isn't going to die soon, but some programmers may if they don't evolve continuously and surf the giant leaps coming along the way.
For some programmers, the salaries and prestige will drop because of the lesser demand and ability to outsource internationally.
For others, the new conditions will simply don't match their expectations, thus slowly decreasing in opportunities and demand.

# Conclusion

In summary, hermit programmers who only write code for themselves are dead because:

- As they don't plan, you never know when (or if) they are going to finish a task.
- As they don't document, their code is not reusable because nobody knows how it works.
- As they don't test, chances are the code they write is full of bugs.
- As they don't refactor, the software cannot evolve.
- As they don't handle infrastructure, their code has only been executed on their machine, and only God knows what will happen when the code runs in production.
- As they don't have good communication skills, they do not know how to sell what they do to the market, which is why they are always behind the competence.
- As they don’t diversify their skills, powerful AI will take over their workplaces.

Unless you're more than just a programmer, it's game over.
But if you are willing to embrace the change and be flexible, there are exciting times ahead!
