<!doctype html><html xmlns=http://www.w3.org/1999/xhtml lang=en-us xml:lang=en-US itemscope itemtype=http://schema.org/WebSite><head><script>(function(){let a=localStorage.getItem('theme');a==='dark'&&document.documentElement.setAttribute('data-theme','dark')})()</script><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><title>AOT vs. JIT Compilation in Java</title><meta name=keywords content="java virtual machine,compilation strategies,compiler,program execution,software performance,"><link rel=alternate type=application/rss+xml title="César Soto Valero  César - Computer Scientist" href=https://www.cesarsotovalero.net/feed.xml><script src=https://cdn.jsdelivr.net/npm/typed.js@2.0.12></script>
<link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Rouge+Script&display=swap" rel=stylesheet><link rel=apple-touch-icon sizes=180x180 href=../img/favicon/redketchup/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../img/favicon/redketchup/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../img/favicon/redketchup/favicon-16x16.png><link rel=manifest href=../img/favicon/redketchup/site.webmanifest><link id=code rel=stylesheet href=../css/pygment_highlights.css><script src=https://d3js.org/d3.v7.min.js></script>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-107061705-1"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','UA-107061705-1')</script><script type=text/javascript>(function(a,e,b,f,g,c,d){a[b]=a[b]||function(){(a[b].q=a[b].q||[]).push(arguments)},c=e.createElement(f),c.async=1,c.src="https://www.clarity.ms/tag/"+g,d=e.getElementsByTagName(f)[0],d.parentNode.insertBefore(c,d)})(window,document,"clarity","script","bs3gcidnol")</script><script src=../js/anchor.min.js></script>
<link rel=stylesheet href=//use.fontawesome.com/releases/v5.12.0/css/all.css><link rel=stylesheet href=/css/bootstrap.min.css><link rel=stylesheet href=/css/bootstrap-social.css><link rel=stylesheet href=/css/main.css><link rel=stylesheet href=/css/academicons.css><link rel=stylesheet href="//fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic"><link rel=stylesheet href="//fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800"><meta name=generator content="Jekyll v4.3.2"><meta property="og:title" content="AOT vs. JIT Compilation in Java"><meta name=author content="César Soto Valero"><meta property="og:locale" content="en_US"><meta name=description content="AOT compilation, supported by the GraalVM compiler, seems to be the future for Java and the programming languages that compile to JVM bytecode. But what is the difference between compiling source code using a JIT compiler w.r.t using an AOT compiler? This post explains the difference between these two approaches."><meta property="og:description" content="AOT compilation, supported by the GraalVM compiler, seems to be the future for Java and the programming languages that compile to JVM bytecode. But what is the difference between compiling source code using a JIT compiler w.r.t using an AOT compiler? This post explains the difference between these two approaches."><link rel=canonical href=https://www.cesarsotovalero.net/blog/aot-vs-jit-compilation-in-java.html><meta property="og:url" content="https://www.cesarsotovalero.net/blog/aot-vs-jit-compilation-in-java.html"><meta property="og:site_name" content="César Soto Valero"><meta property="og:image" content="https://www.cesarsotovalero.net/img/posts/2022/curves_cover.jpg"><meta property="og:type" content="article"><meta property="article:published_time" content="2022-03-27T00:00:00-07:00"><meta name=twitter:card content="summary"><meta property="twitter:image" content="https://www.cesarsotovalero.net/img/posts/2022/curves_cover.jpg"><meta property="twitter:title" content="AOT vs. JIT Compilation in Java"><meta name=twitter:site content="@cesarsotovalero"><meta name=twitter:creator content="@César Soto Valero"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"César Soto Valero","url":"https://www.cesarsotovalero.net/about-me"},"dateModified":"2025-07-29T11:58:39-07:00","datePublished":"2022-03-27T00:00:00-07:00","description":"AOT compilation, supported by the GraalVM compiler, seems to be the future for Java and the programming languages that compile to JVM bytecode. But what is the difference between compiling source code using a JIT compiler w.r.t using an AOT compiler? This post explains the difference between these two approaches.","headline":"AOT vs. JIT Compilation in Java","image":"https://www.cesarsotovalero.net/img/posts/2022/curves_cover.jpg","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.cesarsotovalero.net/blog/aot-vs-jit-compilation-in-java.html"},"publisher":{"@type":"Organization","logo":{"@type":"ImageObject","url":"https://www.cesarsotovalero.net/img/pages/cesar/avatar-icon-2024.jpg"},"name":"César Soto Valero"},"url":"https://www.cesarsotovalero.net/blog/aot-vs-jit-compilation-in-java.html"}</script><script type=text/x-mathjax-config> MathJax.Hub.Config({ TeX: { equationNumbers: { autoNumber: "all" } } });
   </script><script type=text/x-mathjax-config>
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"] ],
          processEscapes: true
        }
      });
   </script><script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type=text/javascript></script></head><body><nav class="navbar-fixed-top navbar-custom navbar navbar-expand-lg navbar-light bg-light"><button class=navbar-toggle type=button data-toggle=collapse data-target=#navbarSupportedContent aria-controls=navbarSupportedContent aria-expanded=false aria-label="Toggle navigation">
<span><i class="fas fa-bars"></i></span></button><div class="collapse navbar-collapse container-fluid" id=navbarSupportedContent><ul class="navigation list-inline text-center footer-links" id=black-icons><li class="nav-item navbar-custom" title=Home><a id=navbar-brand href=https://www.cesarsotovalero.net>Home</a></li><li class="nav-item navbar-custom"><a href=/blog>Blog</a></li><li class="nav-item navbar-custom"><a href=/linkedin>LinkedIn</a></li><li class="nav-item navbar-custom"><a href=/youtube>YouTube</a></li><li class="nav-item navbar-custom"><a href=/podcasts>Podcasts</a></li><li class="nav-item navbar-custom"><a href=/talks>Talks</a></li><li class="nav-item navbar-custom"><a href=/about-me>About</a></li><li class="nav-item navbar-custom" title="Toggle Night Mode"><a href=# id=theme-toggle onclick=modeSwitcher() style=cursor:pointer></a></li></ul></div></nav><header class=header-section><div class="intro-header no-img"><div class=container><div class=row><div class=header-image style=padding-left:15px><div class="row justify-content-center" style=margin-right:0;margin-left:0></div></div><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><div class=post-heading><h1 class=no-anchor>AOT vs. JIT Compilation in Java</h1><h2 class=post-subheading>Which one is better?</h2><div class="container flex-container"><a href=https://www.cesarsotovalero.net/about-me><img class=avatar-img-small src=/img/pages/cesar/avatar-icon-2024.jpg alt="César Soto Valero" id=meta-img></a><div class=flex-item><span class=post-meta>Posted on March 27, 2022</span><div><span class=post-meta title="Estimated read time"><svg id="i-clock" viewBox="0 0 32 32" width="18" height="18" style="vertical-align:middle" fill="none" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="3"><circle cx="16" cy="16" r="14"/><path d="M16 8v8l4 4"/></svg>&nbsp;15 mins read</span>
<span class="blog-tags post-meta"><svg id="i-tag" aria-hidden="true" focusable="false" data-prefix="far" data-icon="tag" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="svg-inline--fa fa-tag fa-w-16" width="16.5" height="16.5"><path fill="none" d="M497.941 225.941 286.059 14.059A48 48 0 00252.118.0H48C21.49.0.0 21.49.0 48v204.118a47.998 47.998.0 0014.059 33.941l211.882 211.882c18.745 18.745 49.137 18.746 67.882.0l204.118-204.118c18.745-18.745 18.745-49.137.0-67.882zM259.886 463.996 48 252.118V48h204.118L464 259.882 259.886 463.996zM192 144c0 26.51-21.49 48-48 48s-48-21.49-48-48 21.49-48 48-48 48 21.49 48 48z"/></svg>java</span></div></div></div><div class=flex-item><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1" style=margin-left:0><section id=share-section><script type=text/javascript src=https://storage.ko-fi.com/cdn/widget/Widget_2.js></script><script type=text/javascript>kofiwidget2.init('Support this blog','#7aa4d1','G2G3CRPPI'),kofiwidget2.draw()</script></section></div></div></div><div class=cesarcarbon id=cesarcarbonads-post><script async type=text/javascript src="//cdn.carbonads.com/carbon.js?serve=CESI52JM&placement=wwwcesarsotovaleronet" id=_carbonads_js></script></div></div></div><div class="col-lg-4 col-lg-pull-2 col-md-2 col-md-pull-2"><ol id=toc class=section-nav><li class="toc-entry toc-h1"><a href=#compilation-in-java>Compilation in Java</a></li><li class="toc-entry toc-h1"><a href=#jit-vs-aot>JIT vs. AOT</a></li><li class="toc-entry toc-h1"><a href=#is-graalvm-the-future-of-java>Is GraalVM the Future of Java?</a></li><li class="toc-entry toc-h1"><a href=#conclusion>Conclusion</a></li><li class="toc-entry toc-h1"><a href=#references>References</a></li><li class="toc-entry toc-h1"><a href=#footnotes>Footnotes</a></li></ol></div></div></div></div></header><div class=container><div class=row><div class="col-lg-9 col-lg-offset-2 col-md-10 col-md-offset-1"><article role=main class=blog-post><p>There are two ways of compiling a Java application: using Just in Time Compilation (JIT) or Ahead of Time Compilation (AOT).
The first is the default mode, and it is used by the <a href=https://www.oracle.com/java/technologies/javase/vmoptions-jsp.html>Java Hotspot Virtual Machine</a> to translate bytecode into machine code at runtime.
The latter is supported by the novel <a href=https://www.graalvm.org/>GraalVM</a> compiler and allows statically compiling bytecode directly into machine code at build time.
In this post, I’ll explain the differences between these two compilation strategies.
After reading this post, you will learn what Java compilers do, the differences between existing compiling approaches, and in which circumstances using an AOT compiler is more appropriate.</p><figure class=jb_picture><img width style=border: src=/assets/resized/curves-640x308.jpg alt="AOT vs. JIT" data-srcset="/assets/resized/curves-640x308.jpg 640w,/assets/resized/curves-768x369.jpg 768w,/assets/resized/curves-1024x492.jpg 1024w,/assets/resized/curves-1366x657.jpg 1366w,/assets/resized/curves-1600x769.jpg 1600w," class="blur-up lazyautosizes lazyload"><figcaption class=stroke>&#169; JIT vs. AOT: two sides of the same coin. Photo from <a href=https://goo.gl/maps/j8GC4KtHEXoKxLpB8>Tekniska Högskolan station</a>.</figcaption></figure><h1 id=compilation-in-java>Compilation in Java</h1><p>Compiling a program means <strong>transforming source code</strong> from a high-level programming language, such as Java or Python, into <a href=https://en.wikipedia.org/wiki/Machine_code>machine code</a>.
Machine code are low-level instructions tailored to execute in a particular microprocessor.
Compilers are programs designed to perform this task efficiently.
The goal of a compiler is to create a consistent executable of the compiled program.
A consistent executable is one that is attained to the specification that is written in the source code, runs fast, and it is safe.</p><p>Compilers perform several <a href=https://en.wikipedia.org/wiki/Category:Compiler_optimizations>optimizations</a> during the machine code generation phase.
For example, most compilers perform constant inlining, loop unrolling, and partial evaluation at compilation time, to name a few.
The quantity and complexity of these optimizations have <a href=https://en.wikipedia.org/wiki/Optimizing_compiler>increased significantly</a> in the last decades.</p><p>In terms of compiler optimizations in the <del>standard</del> Java Hotspot Virtual Machine, there are two major compilers: the C1 compiler and the C2 compiler.</p><ul><li><p>The <strong>C1 compiler</strong> is a fast, lightly optimizing bytecode compiler that performs some value numbering, inlining, and class analysis. It uses a simple CFG-oriented SSA “high” IR, a machine-oriented “low” IR, a linear scan register allocation, and a template-style code generator.</p></li><li><p>The <strong><a href=https://dl.acm.org/doi/10.5555/1267847.1267848>C2 compiler</a></strong> is a highly optimized bytecode compiler that uses a “sea of nodes” SSA “ideal” IR, which lowers to a machine-specific IR of the same kind. It has a graph-coloring register allocator. Colors are machine states, including local, global, and argument registers and stack. Optimizations in the C2 compiler include global value numbering, conditional constant type propagation, constant folding, global code motion, algebraic identities, method inlining (aggressive, optimistic, and/or multi-morphic), intrinsic replacement, loop transformations (unswitching, unrolling), array range check elimination, and others.</p></li></ul><p>Now that we understand the role of compilers, let’s talk about <strong>when</strong> is the compilation performed.
There are two main compilation strategies in Java: Just in Time Compilation (JIT) and Ahead of Time Compilation (AOT).
The first generates machine code <strong>during the execution</strong> of the program itself (i.e., shortly before the first invocation of a Java method).
The latter generates machine code <strong>before the execution</strong> of the program (i.e., during the bytecode verification and build phase of the application).
The following sections describe the differences between these two approaches.</p><h2 id=just-in-time-compilation-jit>Just in Time Compilation (JIT)</h2><p>When compiling a Java program (e.g., using the <code class="language-plaintext highlighter-rouge">javac</code> command line tool), we end up with our source code transformed into an intermediate representation which is platform-independent (a.k.a. JVM bytecode).
This bytecode representation is simpler for the JVM to interpret, but it is harder to read by humans.
Conventional processors in our computers cannot execute JVM bytecode directly.
To do so, a compiler transforms JVM bytecode into a binary representation which is platform-dependent.
This means that the program can be executed only in a computer with the architecture in which it was originally compiled.
This is precisely the task of bytecode compilers.</p><figure class=jb_picture><img width style=border: src=/assets/resized/java_source_code_compilation-640x307.png alt="Java source code compilation phases" data-srcset="/assets/resized/java_source_code_compilation-640x307.png 640w," class="blur-up lazyautosizes lazyload"><figcaption class=stroke>Fig 1. Java source code is first compiled to bytecode, and subsequently interpreted or executed as native code. Heavy optimizations are reserved for the JIT-compilation phase. <a href=https://dl.acm.org/doi/10.1145/3067695.3082521>Source</a>.</figcaption></figure><p>To transform JVM bytecode into machine code that is executable in a specific hardware architecture, the JVM <strong>interprets the bytecode at runtime</strong> and figures out in which architecture is the program running.
This strategy is known as <a href=https://en.wikipedia.org/wiki/Just-in-time_compilation>JIT compilation</a>, which is a form of <a href=https://en.wikipedia.org/wiki/Dynamic_compilation>dynamic compilation</a>.
The default JIT compiler in the JVM is known as the Hotspot compiler.
The <a href=https://github.com/openjdk/jdk>OpenJDK</a> compiler is a free version of this interpreter written in Java.</p><blockquote><p>“In fact, a JIT compiler just needs to be able to accept JVM bytecode and produce machine code: you give it a <code class="language-plaintext highlighter-rouge">byte[]</code> in, and you want a <code class="language-plaintext highlighter-rouge">byte[]</code> back. It will do a lot of complex things to work out how to do that, but they don’t involve the actual system at all, so they don’t need a “systems” language, for some definition of systems language that doesn’t include Java, like C or C++.”</p></blockquote><p>The objective of a JIT compiler is to generate high-quality machine code as fast as possible.
Thanks to the runtime information, JIT compilers perform much more sophisticated optimizations than the <code class="language-plaintext highlighter-rouge">javac</code> compiler.
These optimizations improve performance.</p><p>The Hotspot JIT compiler allows the ample interpreter time to “warm up” Java methods by executing them thousands of times.
This warm-up period allows a compiler to make better decisions related to optimizations because it can observe (after initial class loading) the complete class hierarchy.
The JIT compiler can also inspect branch and type profile information gathered by the interpreter.</p><p>Despite the advances in JIT compilers, Java applications are still a lot slower than other languages such as C or Rust, which produce native code directly.
The bytecode interpretation process makes executing an application significantly slower in comparison with native code being executed directly in a real processor.</p><h2 id=ahead-of-time-compilation-aot>Ahead of Time Compilation (AOT)</h2><p><a href=https://en.wikipedia.org/wiki/Ahead-of-time_compilation>AOT compilation</a> is a form of static compilation that consists of transforming the program into a machine code <strong>before it is executed</strong>.
This is the “old-fashioned” way in which the code in old programming languages such as C is statically linked and compiled.
The machine code obtained as a result is tailored to a specific operating system and hardware architecture, facilitating a very fast execution.</p><p>The <a href=https://github.com/graalvm/graal.git>GraalVM</a> compiler can perform a highly optimized AOT compilation of JVM bytecode.
GraalVM is written in Java and uses JVMCI<sup id=fnref:1><a href=#fn:1 class=footnote rel=footnote role=doc-noteref>1</a></sup> to integrate with the Hotspot VM.
The focus of the GraalVM project is on offering high performance and extensibility of modern Java applications.
This means it executes faster with less overhead, which translates into optimal resource consumption with less CPU and memory.
This makes GraalVM a better alternative than the traditional JIT compiler shipped with the JVM.</p><blockquote><p>“The self-contained native executable created with the <code class="language-plaintext highlighter-rouge">native-image</code> tool in GraalVM includes the application classes, classes from its dependencies, runtime library classes, and statically linked native code from JDK. It does not run on the Java VM, but includes necessary components like memory management, thread scheduling, and so on from a different runtime system, called “Substrate VM.” Substrate VM is the name for the runtime components (like the deoptimizer, garbage collector, and thread scheduling). The resulting program has faster startup time and lower runtime memory overhead compared to a JVM.”</p></blockquote><p>The following figure illustrates the AOT compilation process in the GraalVM compiler using its <a href=https://www.graalvm.org/22.0/reference-manual/native-image/>native-image</a> technology.
It receives as input all classes from the application, libraries, the JDK, and the Java Virtual Machine.
Then an iterative bytecode search using state-of-the-art <a href=https://dl.acm.org/doi/abs/10.1145/3377555.3377885>points-to analysis</a> is performed until a fixed point is reached.
During this process, all the safe classes are <a href=https://docs.oracle.com/en/graalvm/enterprise/21/docs/reference-manual/native-image/ClassInitialization/>initialized upfront</a> (i.e., instantiated) statically.
The class data of the initialized classes is loaded into the image heap which then, in turn, gets saved into standalone executable (into the text section in Fig 2).
The result is a native image executable that can be shipped and deployed directly in a container.</p><figure class=jb_picture><img width=100% style="border:1px solid gray" src=/assets/resized/native_image_creation_process-640x190.png alt="Native image creation process in Quarkus." data-srcset="/assets/resized/native_image_creation_process-640x190.png 640w,/assets/resized/native_image_creation_process-768x228.png 768w,/assets/resized/native_image_creation_process-1024x304.png 1024w," class="blur-up lazyautosizes lazyload"><figcaption class=stroke>Fig 2. Native image creation process in GraalVM. <a href=https://dl.acm.org/doi/10.1145/3360610>Source</a>.</figcaption></figure><p>The AOT compilation in GraalVM performs aggressive optimizations such as unused code elimination in the JDK and its dependencies, heap snapshotting, and static code initializations.
It produces a single executable file.
A major advantage is that the executable does not require having the JVM installed in the client machine to run correctly.
This makes programming languages that compile to JVM bytecode as fast as languages such as C, C++, Rust, or Go which are used for high performing computing.<sup id=fnref:2><a href=#fn:2 class=footnote rel=footnote role=doc-noteref>2</a></sup></p><h1 id=jit-vs-aot>JIT vs. AOT</h1><p>Now that you understand how bytecode compilation works, and the two principal strategies (JIT and AOT), you may wonder which approach is the best to use.
Unfortunately, the answer is as expected: <strong>it depends</strong>.
This section covers the tradeoffs of using one or the other.</p><p>JIT compilers make programs cross-platform. Indeed,
the slogan “<a href=https://en.wikipedia.org/wiki/Write_once,_run_anywhere>write once, run anywhere</a>” is one of the features that made Java a popular language back in the late 90s.
JIT compilers reduce latency thanks to the ability to use concurrent garbage collectors and increase the resilience under peak throughput conditions.</p><p>On the other hand, AOT compilers run programs more efficiently.
AOT compilation is particularly suited for cloud applications.
They offer faster startup speed, which results in shorter boot time and more straightforward horizontal scale-up of cloud services.
This is particularly beneficial in the case of microservices initialized as Docker containers running in the cloud.
The small size on disk, thanks to complete dead code elimination (classes, fields, methods, branches), also results in small container images.
The low memory consumption allows running more containers with the same RAM, reducing the costs of services from cloud providers.</p><p>The following spider graph illustrates the key differences:</p><figure class=jb_picture><img width=100% style="border:1px solid gray" src=/assets/resized/aot_vs_jit-640x393.jpeg alt="AOT vs. JIT." data-srcset="/assets/resized/aot_vs_jit-640x393.jpeg 640w,/assets/resized/aot_vs_jit-768x472.jpeg 768w,/assets/resized/aot_vs_jit-1024x629.jpeg 1024w,/assets/resized/aot_vs_jit-1366x839.jpeg 1366w,/assets/resized/aot_vs_jit-1600x983.jpeg 1600w,/assets/resized/aot_vs_jit-1920x1179.jpeg 1920w," class="blur-up lazyautosizes lazyload"><figcaption class=stroke>Fig 3. AOT vs. JIT. <a href="https://twitter.com/thomaswue/status/1145603781108928513?s=20&t=-6ufSBjc46mfN5d_6Y2-Rg">Source</a>.</figcaption></figure><p>In summary, AOT compilation with GraalVM provides the following advantages over the standard JIT compilation:</p><ul><li>Use a fraction of the resources required by the JVM.</li><li>Applications start in milliseconds.</li><li>Deliver peak performance immediately, no warmup.</li><li>Can be packaged into lightweight container images for faster and more efficient deployments.</li><li>Reduced attack surface.</li></ul><h2 id=the-close-world-assumption>The Close World Assumption</h2><p>The points-to analysis of the AOT compilation needs to “see” all the bytecode to work correctly.
This limitation is known as the close world assumption.
It means that all the bytecode in the application and their dependencies that can be called at runtime <strong>must be known at build time</strong> (observed and analyzed), i.e., when the <code class="language-plaintext highlighter-rouge">native-image</code> tool in GraalVM is building the standalone executable.</p><p>Consequently, <a href=./the-dynamic-features-of-java.html>dynamic language capabilities</a> such as Java Native Interface (JNI), Java Reflection, Dynamic Proxy objects (<code class="language-plaintext highlighter-rouge">java.lang.reflect.Proxy</code>), or classpath resources (<code class="language-plaintext highlighter-rouge">Class.getResource</code>) are not supported.</p><blockquote><p>“The closed-world constraint imposes strict limits on Java’s natural dynamism, particularly on the run-time reflection and class-loading features upon which so many existing Java libraries and frameworks depend. Not all applications are well suited to this constraint, and not all developers are willing to live with it.</p><p>So rather than adopt the closed-world constraint at the start, I propose that we instead pursue a gradual, incremental approach.</p><p>We will explore a spectrum of constraints, weaker than the closed-world constraint, and discover what optimizations they enable. The resulting optimizations will almost certainly be weaker than those enabled by the closed-world constraint. Because the constraints are weaker, however, the optimizations will likely be applicable to a broader range of existing code — thus they will be more useful to more developers.</p><p>We will work incrementally along this spectrum of constraints, starting small and simple so that we can develop a firm understanding of the changes required to the Java Platform Specification. Along the way, we will strive, of course, to preserve Java’s core values of readability, compatibility, and generality.
We will lean heavily on existing components of the JDK including the HotSpot JVM, the C2 compiler, application class-data sharing (CDS), and the <code class="language-plaintext highlighter-rouge">jlink</code> linking tool.</p><p>In the long run, we will likely embrace the full closed-world constraint in order to produce fully static images. Between now and then, however, we will develop and deliver incremental improvements which developers can use sooner rather than later.” – <a href=https://openjdk.java.net/projects/leyden/notes/01-beginnings>Project Leyden: Beginnings</a> (by Oracle)</p></blockquote><p>To overcome this limitation, GraalVM provides a <a href=https://www.graalvm.org/22.0/reference-manual/native-image/Agent/>Tracing Agent</a> that tracks all usages of dynamic features of execution on a regular Java VM.
During execution, the agent interfaces with the JVM and intercepts all calls that look up classes, methods, fields, resources, or request proxy accesses.
The agent then generates the files <code class="language-plaintext highlighter-rouge">jni-config.json</code>, <code class="language-plaintext highlighter-rouge">reflect-config.json</code>, <code class="language-plaintext highlighter-rouge">proxy-config.json</code>, and <code class="language-plaintext highlighter-rouge">resource-config.json</code> in the specified output directory.
The generated files are standalone configuration files in JSON format, which contain all intercepted dynamic accesses.
Thesis files can be passed to the <code class="language-plaintext highlighter-rouge">native-image</code> tool so that the used classes will not be removed during the image build process.</p><p>It is worth mentioning that the close work assumption is good for security as it eliminates the possibility of various code injections (e.g., the <a href=https://nvd.nist.gov/vuln/detail/CVE-2021-44228>Log4j vulnerability</a> that shocked the web in 2021 was possible due to the exploitation of the dynamic class loading mechanism in Java).
On the other hand, the point-to-analysis makes AOT compilation slower than JIT because all the reachable bytecode needs to be analyzed, which is an expensive computational tack.</p><h1 id=is-graalvm-the-future-of-java>Is GraalVM the Future of Java?</h1><p>The benefits of AOT compilation for native cloud applications have increased the interest in this technology. The Java ecosystem is adopting this technology with enthusiasm.
At the moment of writing, four major frameworks benefit from GraalVM to build and optimize applications:</p><ul><li><a href=https://quarkus.io>Quarkus</a> (by RedHat)</li><li><a href=https://micronaut.io>Micronaut</a> (by The Micronaut Foundation)</li><li><a href=https://helidon.io>Helidon</a> (by Oracle)</li><li><a href=https://docs.spring.io/spring-native/docs/current/reference/htmlsingle/>Spring Native</a> (by Spring)</li></ul><p>The common process for building a JVM based native applications is as follows:</p><pre><code class=language-mermaid>%%{init: {'theme':'base'}}%%
flowchart TB;
a([".class Files"]) --&gt; x[Quarkus/Micronatu/Helidon/Spring Native]
x[Quarkus/Micronatu/Helidon/Spring Native] --&gt; y[Maven/Gradle Plugin]
y[Maven/Gradle Plugin] --&gt; q{Optimized JAR for the Cloud}
q -- Yes --&gt; c[AOT Compilation via GraalVM]
q -- No --&gt; w[JIT Compilation via JVM]
c[AOT Compilation via GraalVM] --&gt; r([GraalVM Native Image])
</code></pre><p>It seems that AOT with GraalVM is the future of JVM-based languages, such as Java, Scala, or Kotlin.
However, since the native image creation analyzes the bytecode in the application <strong>and all its dependencies</strong>, there is a risk of violating the close world if at least one of the dependencies relies on some dynamic Java feature.
The community is creating new versions of libraries that respect this assumption.
However, there is still no sufficient support for the most popular Java libraries.
Therefore, the technology still needs some time to mature before its massive adoption.<sup id=fnref:3><a href=#fn:3 class=footnote rel=footnote role=doc-noteref>3</a></sup></p><h1 id=conclusion>Conclusion</h1><p>It is possible to compile JVM bytecode using either AOT or JIT approaches.
It would be wrong to say one approach is better than the other since they are suited for different situations.
The GraalVM compiler allows for building high-performance applications with AOT compilation, reducing the startup time and improving the performance considerably. This power comes at the cost of complying with the close world assumption (no Java dynamic features are allowed). Developers can still use the standard JIT compiler in the Hotspot VM to use dynamic features, which supports machine code generation at runtime.</p><h1 id=references>References</h1><ul><li><a href="https://docs.google.com/presentation/d/1JDVerE77ZWLqwtWP430QXF1KTd4RhKoD/edit?usp=sharing&ouid=117859204590242341300&rtpof=true&sd=true">Java is Going to the Moon: Native Images with GraalVM</a></li><li><a href=https://www.usenix.org/legacy/publications/library/proceedings/jvm02/yu/yu_html/index.html>Supporting Binary Compatibility with Static Compilation</a></li><li><a href=https://dl.acm.org/doi/10.1145/3360610>Initialize Once, Start Fast: Application Initialization at Build Time</a></li><li><a href=https://www.baeldung.com/graal-java-jit-compiler>Deep Dive Into the New Java JIT Compiler – Graal</a></li><li><a href=https://openjdk.java.net/jeps/295>JEP 295: Ahead-of-Time Compilation</a></li><li><a href=https://www.baeldung.com/ahead-of-time-compilation>Ahead of Time Compilation (AoT)</a></li></ul><h1 id=footnotes>Footnotes</h1><div class=footnotes role=doc-endnotes><ol><li id=fn:1><p>The <a href=https://openjdk.java.net/jeps/243>JVMCI</a> is a low-level interface to JVM for features such as reading metadata from the VM and injecting machine code into the VM. It enables compilers written in Java to be used as a dynamic compiler. <a href=#fnref:1 class=reversefootnote role=doc-backlink>&#8617;</a></p></li><li id=fn:2><p>In the case of Go, the fastest initialization was implemented in the language since the beginning. <a href=#fnref:2 class=reversefootnote role=doc-backlink>&#8617;</a></p></li><li id=fn:3><p>Adoption latency is typical in the tech world. Key technology such as Docker containers was available since 2013, but it was not until five years later (in 2018) that it started to receive massive adoption. <a href=#fnref:3 class=reversefootnote role=doc-backlink>&#8617;</a></p></li></ol></div></article><ul class="pager blog-pager"><li class=previous><a href=/blog/how-to-write-a-good-revision-letter.html data-toggle=tooltip data-placement=top title="How to Write a Good Revision Letter For an Academic Paper">&larr; Previous Post</a></li><li class=next><a href=/blog/inversion-of-control-and-dependency-injection-in-java.html data-toggle=tooltip data-placement=top title="Inversion of Control and Dependency Injection in Java">Next Post &rarr;</a></li></ul><br></div></div></div><script>anchors.options={position:'left'},anchors.add('h1:not(.no-anchor)','h2','h3')</script><div class=container><div class=row><div class="col-lg-10 col-lg-offset-2 col-md-10 col-md-offset-1" style=padding-right:15px><div class=flex-container-footer-badges><section class=share-section><a href="https://twitter.com/intent/tweet?text=AOT+compilation%2C+supported+by+the+GraalVM+compiler%2C+seems+to+be+the+future+for+Java+and+the+programming+languages+that+compile+to+JVM+bytecode.+But+what+is+the+difference+between+compiling+source+code+using+a+JIT+compiler+w.r.t+using+an+AOT+compiler%3F+This+post+explains+the+difference+between+these+two+approaches.+https://www.cesarsotovalero.net/blog/aot-vs-jit-compilation-in-java.html" class="btn btn-my-icon btn-twitter" title="Share on Twitter"><span id=share-twitter class="fab fa-twitter" aria-hidden=true></span>
<span class=sr-only>Twitter</span></a>
<a href="https://www.linkedin.com/shareArticle?mini=true&url=https://www.cesarsotovalero.net/blog/aot-vs-jit-compilation-in-java.html" class="btn btn-my-icon btn-linkedin" title="Share on LinkedIn"><span id=share-linkedin class="fab fa-linkedin-in" aria-hidden=true></span>
<span class=sr-only>LinkedIn</span></a>
<a href="https://www.facebook.com/sharer/sharer.php?u=https://www.cesarsotovalero.net/blog/aot-vs-jit-compilation-in-java.html" class="btn btn-my-icon btn-facebook" title="Share on Facebook"><span class="fab fa-facebook-f" aria-hidden=true></span>
<span class=sr-only>Facebook</span></a>
<a href="https://www.reddit.com/submit?url=https%3A%2F%2Fwww.cesarsotovalero.net%2Fblog%2Faot-vs-jit-compilation-in-java.html" class="btn btn-my-icon btn-reddit" title="Share on Reddit"><span class="fab fa-fw fa-reddit" aria-hidden=true></span>
<span class=sr-only>Reddit</span></a>
<a href="https://t.me/share/url?url=https%3A%2F%2Fwww.cesarsotovalero.net%2Fblog%2Faot-vs-jit-compilation-in-java.html&text=AOT+compilation%2C+supported+by+the+GraalVM+compiler%2C+seems+to+be+the+future+for+Java+and+the+programming+languages+that+compile+to+JVM+bytecode.+But+what+is+the+difference+between+compiling+source+code+using+a+JIT+compiler+w.r.t+using+an+AOT+compiler%3F+This+post+explains+the+difference+between+these+two+approaches." class="btn btn-my-icon btn-telegram" title="Share on Telegram"><i class="fab fa-telegram"></i>
<span class=sr-only>Telegram</span></a>
<a href="http://news.ycombinator.com/submitlink?u=https%3A%2F%2Fwww.cesarsotovalero.net%2Fblog%2Faot-vs-jit-compilation-in-java.html&t=AOT+vs.+JIT+Compilation+in+Java" class="btn btn-my-icon btn-hn" title="Share on Hacker News"><i class="fab fa-hacker-news-square"></i>
<span class=sr-only>Hacker News</span></a></section></div><div id=related-posts><hr><h2>Related Posts</h2><div class="panel-deck row"><div class=col-sm-4><div class=panel><a href=/blog/deploying-to-maven-central.html><div class=panel-body><div class=text-left><h4 class=title data-toc-skip>Deploying to Maven Central</h4><div class=date style=margin-bottom:0>Posted on January 6, 2020</div></div><img src=../img/posts/2020/maven_journey_cover.png alt="Deploying to Maven Central"></div></a></div></div><div class=col-sm-4><div class=panel><a href=/blog/the-producer-consumer-pattern-in-java-made-easy.html><div class=panel-body><div class=text-left><h4 class=title data-toc-skip>The Producer-Consumer Pattern in Java Made Easy</h4><div class=date style=margin-bottom:0>Posted on June 28, 2020</div></div><img src=../img/posts/2020/java_design_patterns_cover.jpg alt="The Producer-Consumer Pattern in Java Made Easy"></div></a></div></div><div class=col-sm-4><div class=panel><a href=/blog/the-fork-join-java-framework.html><div class=panel-body><div class=text-left><h4 class=title data-toc-skip>The Fork/Join Java framework</h4><div class=date style=margin-bottom:0>Posted on June 5, 2021</div></div><img src=../img/posts/2021/night_tree_cover.jpg alt="The Fork/Join Java framework"></div></a></div></div></div></div><div><div id=giscus-container></div><script src=/js/load-giscus.js></script>
<script>window.addEventListener('load',loadGiscus)</script></div></div></div></div><script>window.addEventListener('DOMContentLoaded',()=>{const a=new IntersectionObserver(a=>{a.forEach(a=>{const b=a.target.getAttribute('id');a.intersectionRatio>0?document.querySelector(`#toc li a[href="#${b}"]`).parentElement.classList.add('active'):document.querySelector(`#toc li a[href="#${b}"]`).parentElement.classList.remove('active')})});document.querySelectorAll('h1[id]').forEach(b=>{a.observe(b)}),document.querySelectorAll('h2[id]').forEach(b=>{a.observe(b)})})</script><footer><div class="container beautiful-jekyll-footer"><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><div style=text-align:center><div class=flex-container-footer-badges><a href=https://www.linkedin.com/in/cesarsotovalero><img alt="Connect on LinkedIn" src="https://img.shields.io/badge/LinkedIn-Connect-blue?style=social&logo=linkedin"></a>
<a href=https://www.youtube.com/channel/UCR4rI98w6-MqYoCS6jR9LGg><img alt="Subscribe to my YouTube channel" src="https://img.shields.io/youtube/channel/subscribers/UCR4rI98w6-MqYoCS6jR9LGg?logoColor=black&label=Subscribe"></a>
<a href=https://github.com/cesarsotovalero><img alt="Follow me on GitHub" src="https://img.shields.io/github/followers/cesarsotovalero?label=Follow%20me"></a></div></div><div class=flex-container-footer-copyright><p class="copyright text-muted">&copy; César Soto Valero&nbsp;&nbsp;&bull;&nbsp;&nbsp;2018&ndash;2025</p></div></div></div></div></footer><script>typeof jQuery=='undefined'&&document.write('<script src="/js/jquery-1.11.2.min.js"><\/script>')</script><script src=/js/bootstrap.min.js></script>
<script src=/js/main.js></script>
<script src=/js/flowtype.js></script>
<script src=/js/scroll-to-top.js></script>
<script src=/js/lazysizes.min.js></script>
<script src=/js/popup-footnotes.js></script>
<script src=/js/mermaid.min.js></script>
<script>$(document).ready(function(){mermaid.initialize({startOnLoad:!0,theme:"default"}),window.mermaid.init(void 0,document.querySelectorAll('.language-mermaid'))})</script><script>(function(a,e,f,g,b,c,d){a.GoogleAnalyticsObject=b,a[b]=a[b]||function(){(a[b].q=a[b].q||[]).push(arguments)},a[b].l=1*new Date,c=e.createElement(f),d=e.getElementsByTagName(f)[0],c.async=1,c.src=g,d.parentNode.insertBefore(c,d)})(window,document,'script','//www.google-analytics.com/analytics.js','ga'),ga('create','UA-107061705-1','auto'),ga('send','pageview')</script><script src=/js/mode-switcher.js></script></body></html>